<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Corazones</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Parisienne:wght@400;700&display=swap" rel="stylesheet">
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      overflow: hidden;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(180deg, #1a0d1a 0%, #2b0f2b 100%);
      font-family: 'Parisienne', cursive;
    }
    canvas.webgl {
      position: fixed;
      inset: 0;
      outline: none;
      cursor: grab;
    }
    canvas.webgl:active {
      cursor: grabbing;
    }

    .creditos {
      position: fixed;
      bottom: 16px;
      left: 50%;
      transform: translateX(-50%);
      color: #ffccff;
      font-size: clamp(1rem, 2.8vw, 1.4rem);
      text-align: center;
      z-index: 10;
      text-shadow:
        0 0 8px rgba(255, 153, 204, 0.8),
        0 0 16px rgba(255, 153, 204, 0.5);
      letter-spacing: 0.05em;
      pointer-events: none;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <canvas class="webgl"></canvas>
  <div class="creditos">By: ñ§çBerMat_Codeñ§ç</div>

  <!-- Shaders -->
  <script type="x-shader/x-vertex" id="vertexShader">
    #define M_PI 3.1415926535897932384626433832795
    uniform float uTime;
    uniform float uSize;
    attribute float aScale;
    attribute vec3 aColor;
    attribute float random;
    attribute float random1;
    attribute float aSpeed;
    varying vec3 vColor;
    varying vec2 vUv;

    void main() {
      float sign = 2.0 * (step(random, 0.5) - 0.5);
      float t = sign * mod(-uTime * aSpeed * 0.005 + 10.0 * aSpeed * aSpeed, M_PI);
      float a = pow(t, 2.0) * pow((t - sign * M_PI), 2.0);
      float radius = 0.08;
      vec3 myOffset = vec3(
        radius * 16.0 * pow(sin(t), 2.0) * sin(t),
        radius * (13.0 * cos(t) - 5.0 * cos(2.0 * t) - 2.0 * cos(3.0 * t) - cos(4.0 * t)),
        0.15 * (a * (random1 - 0.5)) * sin(abs(10.0 * (sin(0.2 * uTime + 0.2 * random))) * t)
      );
      vec4 modelPosition = modelMatrix * vec4(myOffset, 1.0);
      vec4 viewPosition = viewMatrix * modelPosition;
      viewPosition.xyz += position * aScale * uSize * pow(a, 0.5) * 0.5;
      gl_Position = projectionMatrix * viewPosition;
      vColor = aColor;
      vUv = uv;
    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentShader">
    varying vec3 vColor;
    varying vec2 vUv;
    void main() {
      vec2 uv = vUv;
      vec3 color = vColor;
      float strength = distance(uv, vec2(0.5));
      strength *= 2.0;
      strength = 1.0 - strength;
      gl_FragColor = vec4(strength * color, 1.0);
    }
  </script>

  <script type="x-shader/x-vertex" id="vertexShaderSparks">
    #define M_PI 3.1415926535897932384626433832795
    uniform float uTime;
    uniform float uSize;
    attribute float aScale;
    attribute vec3 aColor;
    attribute float phi;
    attribute float random;
    attribute float random1;
    varying vec3 vColor;
    varying vec2 vUv;

    void main() {
      float t = mod((-uTime + 100.0) * 0.06 * random1 + random * 2.0 * M_PI, 2.0 * M_PI);
      float angle = phi;
      vec3 myOffset = vec3(
        5.85 * cos(angle * t),
        2.0 * (t - M_PI),
        3.0 * sin(angle * t / (t + 0.1))
      );
      vec4 modelPosition = modelMatrix * vec4(myOffset, 1.0);
      vec4 viewPosition = viewMatrix * modelPosition;
      viewPosition.xyz += position * aScale * uSize;
      gl_Position = projectionMatrix * viewPosition;
      vColor = aColor;
      vUv = uv;
    }
  </script>

  <script type="x-shader/x-fragment" id="fragmentShaderSparks">
    uniform sampler2D uTex;
    varying vec3 vColor;
    varying vec2 vUv;
    void main() {
      vec2 uv = vUv;
      vec3 color = vColor;
      float strength = distance(uv, vec2(0.5, 0.65));
      strength *= 2.0;
      strength = 1.0 - strength;
      vec3 texture = texture2D(uTex, uv).rgb;
      gl_FragColor = vec4(texture * color * (strength + 0.3), 1.0);
    }
  </script>

  <script type="module">
    import * as THREE from "https://cdn.skypack.dev/three@0.135.0";
    import { GLTFLoader } from "https://cdn.skypack.dev/three@0.135.0/examples/jsm/loaders/GLTFLoader";

    class HeartScene {
      constructor(canvas) {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0x0a040a);
        this.clock = new THREE.Clock();

        this.camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
        this.camera.position.set(0, 0, 4.5);
        this.scene.add(this.camera);

        this.renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.setClearColor(0x0a040a);

        this.rotation = { x: 0, y: 0 };
        this.isDragging = false;
        this.previousMouse = { x: 0, y: 0 };
        this.cameraDistance = 4.5; // distancia inicial

        this.init();
        this.animate();
        this.setupControls();
        this.handleResize();
      }

      init() {
        this.loadCentralHeart();
        this.createHeartParticles();   // coraz√≥n principal de part√≠culas
        this.createSparkParticles();   // chispas flotantes en el fondo
      }

      loadCentralHeart() {
        const loader = new GLTFLoader();
        loader.load(
          "https://assets.codepen.io/74321/heart.glb",
          (gltf) => {
            this.centralHeart = gltf.scene.children[0];
            this.centralHeart.scale.set(0.25, 0.25, 0.25);
            const matcapTexture = new THREE.TextureLoader().load("https://assets.codepen.io/74321/3.png");
            this.centralHeart.material = new THREE.MeshMatcapMaterial({
              matcap: matcapTexture,
              color: 0xff3366,
              transparent: true,
              opacity: 1
            });
            this.scene.add(this.centralHeart);
          },
          undefined,
          (error) => console.error("Error loading central heart:", error)
        );
      }

      createHeartParticles() {
        const count = 4500; // ‚Üë m√°s part√≠culas
        const geometry = new THREE.InstancedBufferGeometry();
        const baseGeo = new THREE.PlaneGeometry(1, 1);
        Object.keys(baseGeo.attributes).forEach(key => {
          geometry.setAttribute(key, baseGeo.attributes[key]);
        });
        geometry.index = baseGeo.index;

        const scales = new Float32Array(count);
        const colors = new Float32Array(count * 3);
        const speeds = new Float32Array(count);
        const randoms = new Float32Array(count);
        const randoms1 = new Float32Array(count);
        const colorChoices = [0xff66cc, 0xff99ff, 0xffccff, 0xff3366, 0xffffff];

        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          randoms[i] = Math.random();
          randoms1[i] = Math.random();
          scales[i] = Math.random() * 0.35;
          const color = new THREE.Color(colorChoices[Math.floor(Math.random() * colorChoices.length)]);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
          speeds[i] = Math.random() * (12.5 * Math.PI);
        }

        geometry.setAttribute("aScale", new THREE.InstancedBufferAttribute(scales, 1));
        geometry.setAttribute("aColor", new THREE.InstancedBufferAttribute(colors, 3));
        geometry.setAttribute("random", new THREE.InstancedBufferAttribute(randoms, 1));
        geometry.setAttribute("random1", new THREE.InstancedBufferAttribute(randoms1, 1));
        geometry.setAttribute("aSpeed", new THREE.InstancedBufferAttribute(speeds, 1));

        const heartMaterial = new THREE.ShaderMaterial({
          vertexShader: document.getElementById("vertexShader").textContent,
          fragmentShader: document.getElementById("fragmentShader").textContent,
          uniforms: {
            uTime: { value: 0 },
            uSize: { value: 0.22 }
          },
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          transparent: true
        });

        this.particleHeart = new THREE.Mesh(geometry, heartMaterial);
        this.scene.add(this.particleHeart);
      }

      createSparkParticles() {
        const count = 800; // ‚Üë m√°s chispas
        const geometry = new THREE.InstancedBufferGeometry();
        const baseGeo = new THREE.PlaneGeometry(1, 1);
        Object.keys(baseGeo.attributes).forEach(key => {
          geometry.setAttribute(key, baseGeo.attributes[key]);
        });
        geometry.index = baseGeo.index;

        const scales = new Float32Array(count);
        const colors = new Float32Array(count * 3);
        const phis = new Float32Array(count);
        const randoms = new Float32Array(count);
        const randoms1 = new Float32Array(count);
        const colorChoices = [0xff66cc, 0xff99ff, 0xffccff, 0xffffff];

        for (let i = 0; i < count; i++) {
          const i3 = i * 3;
          phis[i] = (Math.random() - 0.5) * 10;
          randoms[i] = Math.random();
          randoms1[i] = Math.random();
          scales[i] = Math.random() * 0.35;
          const color = new THREE.Color(colorChoices[Math.floor(Math.random() * colorChoices.length)]);
          colors[i3] = color.r;
          colors[i3 + 1] = color.g;
          colors[i3 + 2] = color.b;
        }

        geometry.setAttribute("aScale", new THREE.InstancedBufferAttribute(scales, 1));
        geometry.setAttribute("aColor", new THREE.InstancedBufferAttribute(colors, 3));
        geometry.setAttribute("phi", new THREE.InstancedBufferAttribute(phis, 1));
        geometry.setAttribute("random", new THREE.InstancedBufferAttribute(randoms, 1));
        geometry.setAttribute("random1", new THREE.InstancedBufferAttribute(randoms1, 1));

        const sparkMaterial = new THREE.ShaderMaterial({
          vertexShader: document.getElementById("vertexShaderSparks").textContent,
          fragmentShader: document.getElementById("fragmentShaderSparks").textContent,
          uniforms: {
            uTime: { value: 0 },
            uSize: { value: 0.32 },
            uTex: { value: new THREE.TextureLoader().load("https://assets.codepen.io/74321/heart.png") }
          },
          depthWrite: false,
          blending: THREE.AdditiveBlending,
          transparent: true
        });

        this.sparkParticles = new THREE.Mesh(geometry, sparkMaterial);
        this.sparkParticles.position.z = -8; // enviar al fondo
        this.scene.add(this.sparkParticles);
      }

      setupControls() {
        const canvas = this.renderer.domElement;

        // Rotaci√≥n con arrastre
        const onMouseDown = (e) => {
          this.isDragging = true;
          this.previousMouse.x = e.clientX;
          this.previousMouse.y = e.clientY;
          canvas.style.cursor = 'grabbing';
        };

        const onMouseMove = (e) => {
          if (!this.isDragging) return;
          const deltaX = e.clientX - this.previousMouse.x;
          const deltaY = e.clientY - this.previousMouse.y;
          this.rotation.y += deltaX * 0.01;
          this.rotation.x += deltaY * 0.01;
          this.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.rotation.x));
          this.previousMouse.x = e.clientX;
          this.previousMouse.y = e.clientY;
        };

        const onMouseUp = () => {
          this.isDragging = false;
          canvas.style.cursor = 'grab';
        };

        // Zoom con rueda
        const onWheel = (e) => {
          e.preventDefault();
          this.cameraDistance += e.deltaY * 0.005;
          this.cameraDistance = Math.max(1.5, Math.min(12, this.cameraDistance));
        };

        // Toque m√≥vil
        const onTouchStart = (e) => {
          if (e.touches.length === 1) {
            this.isDragging = true;
            this.previousMouse.x = e.touches[0].clientX;
            this.previousMouse.y = e.touches[0].clientY;
          }
        };

        const onTouchMove = (e) => {
          if (!this.isDragging || e.touches.length !== 1) return;
          const deltaX = e.touches[0].clientX - this.previousMouse.x;
          const deltaY = e.touches[0].clientY - this.previousMouse.y;
          this.rotation.y += deltaX * 0.01;
          this.rotation.x += deltaY * 0.01;
          this.rotation.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, this.rotation.x));
          this.previousMouse.x = e.touches[0].clientX;
          this.previousMouse.y = e.touches[0].clientY;
        };

        const onTouchEnd = () => {
          this.isDragging = false;
        };

        canvas.addEventListener('mousedown', onMouseDown);
        window.addEventListener('mousemove', onMouseMove);
        window.addEventListener('mouseup', onMouseUp);
        canvas.addEventListener('wheel', onWheel, { passive: false });

        canvas.addEventListener('touchstart', onTouchStart, { passive: false });
        canvas.addEventListener('touchmove', onTouchMove, { passive: false });
        canvas.addEventListener('touchend', onTouchEnd);
      }

      animate = () => {
        requestAnimationFrame(this.animate);
        const elapsedTime = this.clock.getElapsedTime();

        if (!this.isDragging) {
          this.rotation.y += 0.002;
        }

        // Aplicar rotaci√≥n
        if (this.centralHeart) {
          this.centralHeart.rotation.x = this.rotation.x;
          this.centralHeart.rotation.y = this.rotation.y;
        }
        if (this.particleHeart) {
          this.particleHeart.rotation.x = this.rotation.x;
          this.particleHeart.rotation.y = this.rotation.y;
          if (this.particleHeart.material.uniforms) {
            this.particleHeart.material.uniforms.uTime.value = elapsedTime;
          }
        }
        if (this.sparkParticles && this.sparkParticles.material.uniforms) {
          this.sparkParticles.material.uniforms.uTime.value = elapsedTime;
        }

        // Aplicar zoom
        this.camera.position.z = this.cameraDistance;
        this.camera.lookAt(this.scene.position);

        this.renderer.render(this.scene, this.camera);
      };

      handleResize() {
        window.addEventListener("resize", () => {
          this.camera.aspect = window.innerWidth / window.innerHeight;
          this.camera.updateProjectionMatrix();
          this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
      }
    }

    const canvas = document.querySelector("canvas.webgl");
    new HeartScene(canvas);
  </script>
</body>
</html>
